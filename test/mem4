import Foundation
import AVFoundation

import AVFoundation

func extractAudio(videoFilePath: String, outputFilePath: String) -> Bool {
    let videoURL = URL(fileURLWithPath: videoFilePath)
    let outputURL = URL(fileURLWithPath: outputFilePath)
    
    let asset = AVURLAsset(url: videoURL)
    let audioTrack = asset.tracks(withMediaType: .audio).first
    
    guard let audioTrack = audioTrack else {
        print("未找到音频轨道")
        return false
    }
    
    let audioOutputSettings: [String: Any] = [
        AVFormatIDKey: kAudioFormatLinearPCM,
        AVSampleRateKey: 44100,
        AVNumberOfChannelsKey: 2,
        AVLinearPCMBitDepthKey: 16,
        AVLinearPCMIsFloatKey: false,
        AVLinearPCMIsNonInterleaved: false
    ]
    
    do {
        let assetReader = try AVAssetReader(asset: asset)
        
        let trackOutput = AVAssetReaderTrackOutput(track: audioTrack, outputSettings: audioOutputSettings)
        assetReader.add(trackOutput)
        
        let pcmFile = try AVAudioFile(forWriting: outputURL, settings: audioOutputSettings, commonFormat: .pcmFormatInt16, interleaved: false)
        
        assetReader.startReading()
        pcmFile.framePosition = 0
        
        while let nextBuffer = trackOutput.copyNextSampleBuffer() {
            guard let buffer = CMSampleBufferGetAudioBufferListWithRetainedBlockBuffer(nextBuffer, bufferListSizeNeededOut: nil, bufferListOut: nil, bufferListSize: MemoryLayout<AudioBufferList>.size, blockBufferAllocator: kCFAllocatorDefault, blockBufferMemoryAllocator: kCFAllocatorDefault, flags: kCMSampleBufferFlag_AudioBufferList_Assure16ByteAlignment, bufferOut: nil) else {
                continue
            }
            
            let audioBufferList = UnsafeMutableAudioBufferListPointer(buffer)
            
            for audioBuffer in audioBufferList {
                let data = audioBuffer.mData!.assumingMemoryBound(to: Int16.self)
                let count = Int(audioBuffer.mDataByteSize) / MemoryLayout<Int16>.size
                let frameCount = pcmFile.framePosition + AVAudioFramePosition(count)
                
                let buffer = AVAudioPCMBuffer(pcmFormat: pcmFile.processingFormat, frameCapacity: frameCount)!
                buffer.frameLength = frameCount
                
                let audioBuffer = buffer.audioBufferList.pointee.mBuffers
                audioBuffer.mDataByteSize = buffer.frameCapacity * UInt32(MemoryLayout<Int16>.size)
                audioBuffer.mData = data
                
                pcmFile.write(from: buffer, error: nil)
            }
            
            CMSampleBufferInvalidate(nextBuffer)
        }
        
        pcmFile.framePosition = pcmFile.frameLength
        pcmFile.write(from: AVAudioPCMBuffer(pcmFormat: pcmFile.processingFormat, frameCapacity: 0)!, error: nil)
        
        assetReader.cancelReading()
        return true
    } catch {
        print("音频提取和解码失败: \(error.localizedDescription)")
        return false
    }
}

// 使用示例
let videoFilePath = "/path/to/input.mp4"
let outputFilePath = "/path/to/output.pcm"

let extractionSuccess = extractAudio(videoFilePath: videoFilePath, outputFilePath: outputFilePath)
if extractionSuccess {
    print("音轨提取和解码成功")
} else {
    print("音轨提取和解码失败")
}


// 写入 WAV 文件头
func writeWavHeader(to outputStream: OutputStream, format: CMAudioFormatDescription) {
    var basicDescription = AudioStreamBasicDescription()
    let formatDescription = CMAudioFormatDescriptionGetStreamBasicDescription(format)
    memcpy(&basicDescription, formatDescription, MemoryLayout<AudioStreamBasicDescription>.size)
    
    // WAV 文件头信息
    var wavHeader = WavHeader()
    wavHeader.riffChunkID = "RIFF".toUInt32()
    wavHeader.riffChunkSize = 0
    wavHeader.waveChunkID = "WAVE".toUInt32()
    wavHeader.formatChunkID = "fmt ".toUInt32()
    wavHeader.formatChunkSize = 16
    wavHeader.audioFormat = kAudioFormatLinearPCM
    wavHeader.numChannels = basicDescription.mChannelsPerFrame
    wavHeader.sampleRate = Int32(basicDescription.mSampleRate)
    wavHeader.byteRate = Int32(basicDescription.mBytesPerFrame * basicDescription.mSampleRate)
    wavHeader.blockAlign = basicDescription.mBytesPerFrame
    wavHeader.bitsPerSample = 16
    wavHeader.dataChunkID = "data".toUInt32()
    wavHeader.dataChunkSize = 0
    
    // 写入 WAV 文件头
    withUnsafeBytes(of: &wavHeader) { (ptr: UnsafeRawBufferPointer) -> Void in
        outputStream.write(ptr.baseAddress!.assumingMemoryBound(to: UInt8.self), maxLength: MemoryLayout<WavHeader>.size)
    }
}

// WAV 文件头结构体
struct WavHeader {
    var riffChunkID: UInt32
    var riffChunkSize: UInt32
    var waveChunkID: UInt32
    var formatChunkID: UInt32
    var formatChunkSize: UInt32
    var audioFormat: UInt16
    var numChannels: UInt16
    var sampleRate: Int32
    var byteRate: Int32
    var blockAlign: UInt16
    var bitsPerSample: UInt16
    var dataChunkID: UInt32
    var dataChunkSize: UInt32
    
    init() {
        riffChunkID = 0
        riffChunkSize = 0
        waveChunkID = 0
        formatChunkID = 0
        formatChunkSize = 0
        audioFormat = 0
        numChannels = 0
        sampleRate = 0
        byteRate = 0
        blockAlign = 0
        bitsPerSample = 0
        dataChunkID = 0
        dataChunkSize = 0
    }
}

// 辅助方法：将字符串转为 UInt32
extension String {
    func toUInt32() -> UInt32 {
        let utf8Data = data(using: .utf8)!
        let value = utf8Data.withUnsafeBytes { $0.load(as: UInt32.self) }
        return UInt32(bigEndian: value)
    }
}

// 使用示例
let videoFilePath = "/path/to/inputfile.mp4"
let wavFilePath = "/path/to/outputfile.wav"

let success = extractAudioToWav(videoFilePath: videoFilePath, wavFilePath: wavFilePath)
print("提取音轨并保存为 PCM 文件结果：\(success)")



// Write WAV file header
func writeWavHeader(to outputStream: OutputStream, format: CMAudioFormatDescription) {
    var basicDescription = AudioStreamBasicDescription()
    let formatDescription = CMAudioFormatDescriptionGetStreamBasicDescription(format)
    memcpy(&basicDescription, formatDescription, MemoryLayout<AudioStreamBasicDescription>.size)
    
    // WAV file header information
    var wavHeader = WavHeader()
    wavHeader.riffChunkID = "RIFF".toUInt32()
    wavHeader.riffChunkSize = 0
    wavHeader.waveChunkID = "WAVE".toUInt32()
    wavHeader.formatChunkID = "fmt ".toUInt32()
    wavHeader.formatChunkSize = 16
    wavHeader.audioFormat = basicDescription.mFormatID.rawValue // Assign the rawValue of the AudioFormatId enum
    wavHeader.numChannels = basicDescription.mChannelsPerFrame
    wavHeader.sampleRate = Int32(basicDescription.mSampleRate)
    wavHeader.byteRate = Int32(basicDescription.mBytesPerFrame * basicDescription.mSampleRate)
    wavHeader.blockAlign = basicDescription.mBytesPerFrame
    wavHeader.bitsPerSample = 16
    wavHeader.dataChunkID = "data".toUInt32()
    wavHeader.dataChunkSize = 0
    
    // Write WAV file header
    withUnsafeBytes(of: &wavHeader) { (ptr: UnsafeRawBufferPointer) -> Void in
        outputStream.write(ptr.baseAddress!.assumingMemoryBound(to: UInt8.self), maxLength: MemoryLayout<WavHeader>.size)
    }
}

}

// WAV 文件头结构体
struct WavHeader {
    var riffChunkID: UInt32
    var riffChunkSize: UInt32
    var waveChunkID: UInt32
    var formatChunkID: UInt32
    var formatChunkSize: UInt32
    var audioFormat: UInt16
    var numChannels: UInt16
    var sampleRate: Int32
    var byteRate: Int32
    var blockAlign: UInt16
    var bitsPerSample: UInt16
    var dataChunkID: UInt32
    var dataChunkSize: UInt32
    
    init() {
        riffChunkID = 0
        riffChunkSize = 0
        waveChunkID = 0
        formatChunkID = 0
        formatChunkSize = 0
        audioFormat = 0
        numChannels = 0
        sampleRate = 0
        byteRate = 0
        blockAlign = 0
        bitsPerSample = 0
        dataChunkID = 0
        dataChunkSize = 0
    }
}

// 辅助方法：将字符串转为 UInt32
extension String {
    func toUInt32() -> UInt32 {
        let utf8Data = data(using: .utf8)!
        let value = utf8Data.withUnsafeBytes { $0.load(as: UInt32.self) }
        return UInt32(bigEndian: value)
    }
}

// 使用示例
let videoFilePath = "/path/to/inputfile.mp4"
let wavFilePath = "/path/to/outputfile.wav"

let success = extractAudioToWav(videoFilePath: videoFilePath, wavFilePath: wavFilePath)
print("提取音轨并保存为 PCM 文件结果：\(success)")
