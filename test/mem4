import AVFoundation

func extractAudio(inputPath: String, outputPath: String) -> Bool {
    let inputURL = URL(fileURLWithPath: inputPath)
    let outputURL = URL(fileURLWithPath: outputPath)

    let asset = AVAsset(url: inputURL)

    // Create an export session with the desired output file type
    guard let exportSession = AVAssetExportSession(asset: asset, presetName: AVAssetExportPresetPassthrough) else {
        print("Failed to create export session")
        return false
    }

    // Specify the output format and file type (e.g., M4A)
    exportSession.outputFileType = .m4a
    exportSession.outputURL = outputURL

    // Get the audio track from the asset
    guard let audioTrack = asset.tracks(withMediaType: .audio).first else {
        print("No audio track found")
        return false
    }

    // Set the time range to extract the full audio track
    let timeRange = CMTimeRange(start: CMTime.zero, duration: asset.duration)
    exportSession.timeRange = timeRange

    // Export the audio track asynchronously
    let exportSemaphore = DispatchSemaphore(value: 0)
    exportSession.exportAsynchronously {
        switch exportSession.status {
        case .completed:
            print("Audio extraction completed successfully")
            exportSemaphore.signal()
        case .failed, .cancelled, .unknown:
            if let error = exportSession.error {
                print("Audio extraction failed with error: \(error.localizedDescription)")
            } else {
                print("Audio extraction failed")
            }
            exportSemaphore.signal()
        default:
            break
        }
    }

    _ = exportSemaphore.wait(timeout: .distantFuture)

    return exportSession.status == .completed
}

// Usage example
let inputPath = "/path/to/input/video.mp4"
let outputPath = "/path/to/output/audio.m4a"

if extractAudio(inputPath: inputPath, outputPath: outputPath) {
    print("Audio extraction completed")
} else {
    print("Audio extraction failed")
}
